# 1 设计模式

## 1.1 使用设计模式的目的
> 1. 提高代码的可重复利用
> 2. 提高代码的可读性
> 3. 保障代码的可靠性

## 1.2 设计模式的六大原则
> 1. 单一职责原则：类或者接口要实现职责单一
> 2. 里氏替换原则：使用子类来替换父类，做出通用的编程
> 3. 依赖倒置原则：面向接口编程
> 4. 接口隔离原则：接口的设计需要精简单一
> 5. 迪米特法则：降低依赖之间耦合
> 6. 开闭原则：对扩展开放，对修改关闭

## 1.3 单例模式---singleton
单例模式（Singleton Pattern）是 Java 中最常见的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一 种创建对象的最佳方式。
单例模式：涉及到一个单一的类，该类负责创建自己的对象，同时确保只有一个对象被创建。该类还提供一种访问他的唯一对象的方式，其他类可以直接访问该方法获取该对象实例而不需要实例化该类的对象。

单例模式的特点：
> 1. 单例类只能有一个实例。
> 2. 单例类必须自己创建自己的唯一实例。
> 3. 单例类必须给所有其他对象提供这一实例。

单例模式的优点：
> 1. 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。
> 2. 避免对资源的多重占用（比如写文件操作）。

单例模式的真实使用场景：
> 1. 网站的计数器
> 2. 应用程序的日志应用
> 3. 数据库连接池设计
> 4. 多线程的线程池设计

### 1.3.1 单例模式
实现步骤：
1. 整个应用只有一个自己的实例 
2. 只能自己创建自己
3. 需要提供一个方法让外界访问自己

饿汉式：
> 创建一个单例对象 HungrySingleModel , HungrySingleModel 类有它的私有构造函数和本身的一个静态实例。
> HungrySingleModel 类提供了一个静态方法，供外界获取它的静态实例。 SingletonTest 我们的演示类使用 HungrySingleModel 类来获取对象。

懒汉式：
> 1.延迟加载创建，也就是用到对象的时候，才会创建
> 2.线程安全问题需要手动处理(不添加同步方法，线程不安全，添加了同步方法，效率低)
> 3.实现容易

双重检验锁：
> 这种方式采用双锁机制，安全且在多线程情况下能保持高性能。
> 如果有A，B两个线程，第一次判断null,如果A和B为null,这样A和B就是并发场景。A获取锁进入下一个null判断
> 判断为null就会创建实例,释放锁。B获取锁进来，如果没有第二次判断为null，则B还会创建实例。


### 1.3.2 观测者模式---observer
定义：
> 对象之间存在一对多或者一对一依赖，当一个状态改变，依赖他的对象会收到他的消息并自动更新
> MQ其实就属于一种观察者模式，发布者发布信息，订阅者获取信息，订阅了就能收到信息，没订阅就收不到信息。

优点：
> 1. 观察者和被观察者是抽象耦合的
> 2. 建立一套独立的触发机制

缺点：
> 1. 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间
> 2. 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃

### 1.3.3 
