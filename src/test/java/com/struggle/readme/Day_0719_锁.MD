# 1 synchronized的三种应用方式

> synchronized关键字最主要有以下3种应用方式，下面分别介绍
>* **修饰实例方法**，作用于当前实例加锁，进入同步代码前要获得当前实例的锁
>* **修饰静态方法**，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁
>* **修饰代码块**，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

## 1.1 synchronized作用于实例方法

> * 把synchronized加在实例方法上，锁住的是this对象
> * 使用同一个对象的不同方法进行共享资源的操作使用这种方式
> * 所谓的实例对象锁就是用synchronized修饰实例对象中的实例方法

```java
class Test {
    public synchronized void add() {

    }
}

//等价于
class Test {
    public void add() {
        synchronized (this) {

        }
    }
}
```

```java
public class AccountingSync implements Runnable {
    //共享资源(临界资源)
    static int i = 0;

    /**
     * synchronized 修饰实例方法
     * 非静态,访问时锁不一样不会发生互斥
     */
    public synchronized void increase() {
        i++;
    }

    @Override
    public void run() {
        for (int j = 0; j < 1000000; j++) {
            increase();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        test1();
        AccountingSync.i = 0;
        test2();
    }

    private static void test1() throws InterruptedException {
        AccountingSync instance = new AccountingSync();
        Thread t1 = new Thread(instance);
        Thread t2 = new Thread(instance);
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println(i);//2000000
    }

    private static void test2() throws InterruptedException {
        //new新实例
        Thread t1 = new Thread(new AccountingSync());
        //new新实例
        Thread t2 = new Thread(new AccountingSync());
        t1.start();
        t2.start();
        //join用于让当前执行线程[main]等待join线程执行结束。
        //其实现原理是不停检查join线程是否存活，如果join线程存活则让当前线程永远等待。
        t1.join();
        t2.join();
        System.out.println(i);//不一定是2000000
    }
}
```

## 1.2 synchronized作用于静态方法

> * 把synchronized加在静态方法上，锁住的是类对象
> * 使用不同对象的方法进行共享资源的操作使用这种方式

```java
class Test {
    public synchronized static void add() {

    }
}

//等价于
class Test {
    public static void add() {
        synchronized (Test.class) {

        }
    }
}
```

```java
public class AccountingSyncClass implements Runnable {
    //共享资源(临界资源)
    static int i = 0;

    /**
     * 作用于静态方法,锁是当前class对象,也就是 AccountingSync 类对应的class对象
     */
    public static synchronized void increase() {
        i++;
    }

    @Override
    public void run() {
        for (int j = 0; j < 1000000; j++) {
            increase();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        test1();
        AccountingSyncClass.i = 0;
        test2();
    }

    private static void test1() throws InterruptedException {
        AccountingSyncClass instance = new AccountingSyncClass();
        Thread t1 = new Thread(instance);
        Thread t2 = new Thread(instance);
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println(i);//2000000
    }

    private static void test2() throws InterruptedException {
        //new新实例
        Thread t1 = new Thread(new AccountingSyncClass());
        //new新实例
        Thread t2 = new Thread(new AccountingSyncClass());
        t1.start();
        t2.start();
        //join用于让当前执行线程[main]等待join线程执行结束。
        //其实现原理是不停检查join线程是否存活，如果join线程存活则让当前线程永远等待。
        t1.join();
        t2.join();
        System.out.println(i);//2000000
    }
}
```

## 1.3 synchronized同步代码块

> 在某些情况下，我们编写的方法体可能比较大，同时存在一些比较耗时的操作，而需要同步的代码又只有一小部分，如果直接对整个方法进行同步操作，可能会得不偿失，此时我们可以使用同步代码块的方式对需要同步的代码进行包裹，这样就无需对整个方法进行同步操作了，同步代码块的使用示例如下：

```java
public class AccountingSync implements Runnable {
    static AccountingSync instance = new AccountingSync();
    static int i = 0;

    @Override
    public void run() {
        //省略其他耗时操作....
        //使用同步代码块对变量i进行同步操作,锁对象为instance
        synchronized (instance) {
            for (int j = 0; j < 1000000; j++) {
                i++;
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(instance);
        Thread t2 = new Thread(instance);
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println(i);//2000000
    }
}
```

> 从代码看出，将synchronized作用于一个给定的实例对象instance，即当前实例对象就是锁对象，每次当线程进入synchronized包裹的代码块时就会要求当前线程持有instance实例对象锁，如果当前有其他线程正持有该对象锁，那么新到的线程就必须等待，这样也就保证了每次只有一个线程执行i++;操作。当然除了instance作为对象外，我们还可以使用this对象(代表当前实例)或者当前类的class对象作为锁，如下代码：

```text
//this,当前实例对象锁
synchronized(this){
    for(int j=0;j<1000000;j++){
        i++;
    }
}

//class对象锁
synchronized(AccountingSync.class){
    for(int j=0;j<1000000;j++){
        i++;
    }
}
```

# 1 乐观锁CAS

# 2 悲观锁synchronized、vector、hashtable

# 3 自旋锁CAS

# 4 可重入锁synchronized、Reentrantlock、Lock

# 5 读写锁ReentrantReadWriteLock，CopyOnWriteArrayList、CopyOnWriteArraySet

# 6 公平锁Reentrantlock(true)

# 7 非公平锁synchronized、reentrantlock(false)

# 8 共享锁ReentrantReadWriteLock中读锁

# 9 独占锁synchronized、vector、hashtable、ReentrantReadWriteLock中写锁

# 10 重量级锁synchronized

# 11 轻量级锁锁优化技术

# 12 偏向锁锁优化技术

# 13 分段锁concurrentHashMap

# 14 互斥锁synchronized

# 15 同步锁synchronized

# 16 死锁相互请求对方的资源

# 17 锁粗化锁优化技术

# 18 锁消除锁优化技术